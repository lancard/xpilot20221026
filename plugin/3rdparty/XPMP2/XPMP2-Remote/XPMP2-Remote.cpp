/// @file       XPMP2-Remote.cpp
/// @brief      XPMP2 Remote Client: Displays aircraft served from other
///             XPMP2-based plugins in the network
/// @details    This plugin is intended to be used in a multi-computer simulator
///             setup, usually in the PCs used for external visuals.\n
///             The typical setup would be:
///             - There is a multi-computer setup of one X-Plane Master PC,
///               which also runs one or more XPMP2-based plugins like LiveTraffic,
///               which create additional traffic, let's call them "traffic master".
///             - Other PCs serve to compute additional external visuals.
///               For them to be able to show the very same additional traffic
///               they run XPMP2 Remote Client, which will display a copy
///               of the traffic generated by the XPMP2-based plugin on the master.
///
///             Technically, this works as follows:
///             - The "traffic masters" will first _listen_
///               on the network if anyone is interested in their data.
///             - The XPMP2 Remote Client will first send a "beacon of interest"
///               message to the network.
///             - This messages tells the master plugins to start feeding their data.
///             - All communication is UDP multicast on the same multicast
///               group that X-Plane uses, too: 239.255.1.1, but on a different
///               port: 49788
///             - This generic way allows for many different setups:
///               - While the above might be typical, it is not of interest if the
///                 "traffic master" is running on the X-Plane Master or any
///                 other X-Plane instance in the network, for example to
///                 better balance the load.
///               - It could even be an X-Plane PC not included in the
///                 External Visuals setup, like for example in a Networked
///                 Multiplayer setup.
///               - Multiple XPMP2-based traffic masters can be active, and
///                 they can even run on different PCs. The one XPMP2 Remote Client
///                 per PC will still collect all traffic.
///               - If several traffic masters run on different PCs, then _all_
///                 PCs, including the ones running one of the traffic masters,
///                 will need to run the XPMP2 Remote Client, so that they
///                 pick up the traffic generated on the _other_ traffic masters.
///
/// @see        For multi-computer setup of external visual:
///             https://x-plane.com/manuals/desktop/#networkingmultiplecomputersformultipledisplays
/// @see        For Networked Multiplayer:
///             https://x-plane.com/manuals/desktop/#networkedmultiplayer
/// @author     Birger Hoppe
/// @copyright  (c) 2020 Birger Hoppe
/// @copyright  Permission is hereby granted, free of charge, to any person obtaining a
///             copy of this software and associated documentation files (the "Software"),
///             to deal in the Software without restriction, including without limitation
///             the rights to use, copy, modify, merge, publish, distribute, sublicense,
///             and/or sell copies of the Software, and to permit persons to whom the
///             Software is furnished to do so, subject to the following conditions:\n
///             The above copyright notice and this permission notice shall be included in
///             all copies or substantial portions of the Software.\n
///             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
///             THE SOFTWARE.

// All headers are collected in one
#include "XPMP2-Remote.h"

//
// MARK: Utility Functions
//

/// This is a callback the XPMP2 calls regularly to learn about configuration settings.
/// Only 3 are left, all of them integers.
int CBIntPrefsFunc (const char *, [[maybe_unused]] const char * item, int defaultVal)
{
    // We always want to replace dataRefs and textures upon load to make the most out of the .obj files
    if (!strcmp(item, XPMP_CFG_ITM_REPLDATAREFS))   return rcGlob.mergedS.bObjReplDataRefs; // taken from sending plugins
    if (!strcmp(item, XPMP_CFG_ITM_REPLTEXTURE))    return rcGlob.mergedS.bObjReplTextures; // taken from sending plugins
    if (!strcmp(item, XPMP_CFG_ITM_CLAMPALL))       return 0;                               // Never needed: The defining coordinates are sent to us, don't interpret them here in any way
    if (!strcmp(item, XPMP_CFG_ITM_HANDLE_DUP_ID))  return 1;                               // must be on: if receiving from different plugins we can easily run in duplicate ids, which shall be handled
    if (!strcmp(item, XPMP_CFG_ITM_SUPPORT_REMOTE)) return -1;                              // We don't want this plugin to ever _send_ traffic!
    if (!strcmp(item, XPMP_CFG_ITM_LOGLEVEL))       return (int)rcGlob.mergedS.logLvl;      // taken from sending plugins
    if (!strcmp(item, XPMP_CFG_ITM_MODELMATCHING))  return rcGlob.mergedS.bLogMdlMatch;     // taken from sending plugins
    // Otherwise we just accept defaults
    return defaultVal;
}

//
// MARK: Menu / Command functionality
//

XPLMMenuID hMenu = nullptr;         ///< menu id of our plugin's menu
XPLMMenuID hLabels = nullptr;       ///< menu id of the Labels submenu
XPLMMenuID hSenders = nullptr;      ///< menu id of the Senders submenu
int numSendersInMenu = 0;           ///< how many lines to we currently server in the menu?

// menu indexes
constexpr std::uintptr_t MENU_ACTIVE = 0;
constexpr std::uintptr_t MENU_TCAS   = 1;
constexpr std::uintptr_t MENU_LABELS = 2;
constexpr std::uintptr_t MENU_SENDER = 3;

/// Command definition per menu item
struct CmdMenuDefTy {
    const char* cmdName = nullptr;          ///< command's name
    const char* menuName = nullptr;         ///< (initial) menu item's name
    const char* description = nullptr;      ///< human-readable command description
    XPLMCommandRef hCmd = nullptr;          ///< command reference assigned by X-Plane
} CMD_MENU_DEF[2] = {
    { "XPMP2-Remote/Activate",  "Active",       "Toggle if Remote Client is active" },
    { "XPMP2-Remote/TCAS",      "TCAS Control", "Toggle if Remote Client shall have TCAS control" },
};

/// Sets all menu checkmarks according to current status
void MenuUpdateCheckmarks ()
{
    // Menu item "Active"
    switch (XPMP2::RemoteGetStatus()) {
        case XPMP2::REMOTE_RECV_WAITING:
            XPLMSetMenuItemName(hMenu, MENU_ACTIVE, "Active (waiting for data)", 0);
            XPLMCheckMenuItem(hMenu, MENU_ACTIVE, xplm_Menu_Checked);
            break;

        case XPMP2::REMOTE_RECEIVING: {
            char s[50];
            snprintf (s, sizeof(s), "Active (%ld aircraft)", XPMPCountPlanes());
            XPLMSetMenuItemName(hMenu, MENU_ACTIVE, s, 0);
            XPLMCheckMenuItem(hMenu, MENU_ACTIVE, xplm_Menu_Checked);
            break;
        }
            
        default:
            XPLMSetMenuItemName(hMenu, MENU_ACTIVE, "Activate (currently inactive)", 0);
            XPLMCheckMenuItem(hMenu, MENU_ACTIVE, xplm_Menu_Unchecked);
            break;
    }
    
    // Menu item "TCAS Control" (status display)
    XPLMCheckMenuItem(hMenu, MENU_TCAS, XPMPHasControlOfAIAircraft() ? xplm_Menu_Checked : xplm_Menu_Unchecked);

    // Sub menu "Labels"
    for (XPMP2RCGlobals::DrawLabelsTy e = XPMP2RCGlobals::LABELS_SYNCH;
         e <= XPMP2RCGlobals::LABELS_OFF; e = XPMP2RCGlobals::DrawLabelsTy(e + 1))
        XPLMCheckMenuItem(hLabels, e, rcGlob.eDrawLabels == e ? xplm_Menu_Checked : xplm_Menu_Unchecked);
}

/// (Re)Create the submenu listing information about connected senders
void MenuUpdateSenders ()
{
    // Simple case first: There is no sender
    if (rcGlob.gmapSender.empty()) {
        // If we show anything we must remove it
        if (numSendersInMenu > 0) {
            XPLMClearAllMenuItems(hSenders);
            XPLMAppendMenuItem(hSenders, "(none)", (void*)MENU_SENDER, 0);
            numSendersInMenu = 0;
        }
        return;
    }
    
    // There are senders, fill in their details
    if (numSendersInMenu == 0)      // physically there's always one menu item that we can re-use
        numSendersInMenu++;
    
    // Cycle over senders and update textual information
    int idx = 0;
    for (const mapSenderTy::value_type& p: rcGlob.gmapSender)
    {
        const SenderTy& snd = p.second;
        
        // Put together plugin name, IP address, number of aircraft
        std::string s (STR_N(snd.settings.name));
        if (!snd.bLocal) {
            s += " @ ";
            s += snd.sFrom;
        }
        s += ": ";
        s += std::to_string(snd.mapAc.size());
        s += " aircraft";
        
        // Do we need a new menu item or can we update an existing one?
        if (idx < numSendersInMenu)
            XPLMSetMenuItemName(hSenders, idx, s.c_str(), 0);
        else {
            XPLMAppendMenuItem(hSenders, s.c_str(), (void*)MENU_SENDER, 0);
            numSendersInMenu++;
        }
        idx++;
    }
    
    // Remove left-over menu items
    while (idx < numSendersInMenu)
        XPLMRemoveMenuItem(hSenders, --numSendersInMenu);
}


/// Callback function for menu
int CmdCallback (XPLMCommandRef cmdRef, XPLMCommandPhase inPhase, void*)
{
    // entry point into plugin...catch exceptions latest here
    try {
        if (inPhase == xplm_CommandBegin) {
            if (cmdRef == CMD_MENU_DEF[0].hCmd) {
                // Toggle activation of plugin
                ClientToggleActive();
            }
            else if (cmdRef == CMD_MENU_DEF[1].hCmd) {
                // Toggle TCAS/AI status
                if (XPMPHasControlOfAIAircraft())
                    ClientReleaseAI();
                else
                    ClientTryGetAI();
            }
            
            // Update check marks...things might have changed
            MenuUpdateCheckmarks();
        }
    }
    catch (const std::exception& e) {
        LOG_MSG(logFATAL, ERR_EXCEPTION, e.what());
    }
    return 1;
}


/// Callback function for the Labels submenu
void MenuLabelsCB (void* /*inMenuRef*/, void* inItemRef)
{
    // entry point into plugin...catch exceptions latest here
    try {
        XPMP2RCGlobals::DrawLabelsTy eDrawLabels =
        XPMP2RCGlobals::DrawLabelsTy(reinterpret_cast<long long>(inItemRef));
        switch (eDrawLabels) {
                // Enable label-drawing in principal
            case XPMP2RCGlobals::LABELS_SYNCH:
            case XPMP2RCGlobals::LABELS_ON:
                rcGlob.eDrawLabels = eDrawLabels;
                XPMPEnableAircraftLabels();
                break;
                
                // Disable label drawing completely
            case XPMP2RCGlobals::LABELS_OFF:
                rcGlob.eDrawLabels = XPMP2RCGlobals::LABELS_OFF;
                XPMPDisableAircraftLabels();
                break;
        }
        // Update check marks...things might have changed
        MenuUpdateCheckmarks();
    }
    catch (const std::exception& e) {
        LOG_MSG(logFATAL, ERR_EXCEPTION, e.what());
    }
}

//
// MARK: Regular Tasks
//

/// ID of our flight loop callback for regular tasks
XPLMFlightLoopID flId = nullptr;

/// Regular tasks, called by flight loop
float FlightLoopCallback(float, float, int, void*)
{
    // entry point into plugin...catch exceptions latest here
    try {
        GetMiscNetwTime();              // update rcGlob.now, e.g. for logging from worker threads
        // if there aren't any planes yet then the XPMP2 library won't call ClientFlightLoopBegins(), instead we do
        if (XPMPCountPlanes() == 0) {
            try {
                // The first plane(s) would be instanciated here, and that could fail, e.g. if there are no CSL models installed
                ClientFlightLoopBegins();
            }
            catch (const std::exception& e) {
                LOG_MSG(logFATAL, ERR_EXCEPTION, e.what());
            }
            ClientFlightLoopEnds();
        }
        MenuUpdateCheckmarks();         // update menu
        MenuUpdateSenders();
    }
    catch (const std::exception& e) {
        LOG_MSG(logFATAL, ERR_EXCEPTION, e.what());
    }
    
    // call me every second only
    return 1.0f;
}

//
// MARK: Standard Plugin Callbacks
//

PLUGIN_API int XPluginStart(char* outName, char* outSig, char* outDesc)
{
#ifdef DEBUG
    rcGlob.mergedS.logLvl = logDEBUG;
#endif
    // this is the XP main thread
    rcGlob.xpThread = std::this_thread::get_id();
    GetMiscNetwTime();
    
    LOG_MSG(logMSG, "%s %.2f starting up...", REMOTE_CLIENT_NAME, REMOTE_CLIENT_VER);

    std::snprintf(outName, 255, "%s %.2f", REMOTE_CLIENT_NAME, REMOTE_CLIENT_VER);
    std::strcpy(outSig,  XPMP2::REMOTE_SIGNATURE);
	std::strcpy(outDesc, "Remote Client displaying traffic generated by XPMP2-based plugins on the network");
    
    // use native paths, i.e. Posix style (as opposed to HFS style)
    // https://developer.x-plane.com/2014/12/mac-plugin-developers-you-should-be-using-native-paths/
    XPLMEnableFeature("XPLM_USE_NATIVE_PATHS",1);

    // The path separation character, one out of /\:
    char pathSep = XPLMGetDirectorySeparator()[0];
    // The plugin's path, results in something like ".../Resources/plugins/XPMP2-Remote/64/XPMP2-Remote.xpl"
    char szPath[256];
    rcGlob.mergedS.pluginId = std::uint16_t(XPLMGetMyID());
    XPLMGetPluginInfo(XPLMGetMyID(), nullptr, szPath, nullptr, nullptr);
    *(std::strrchr(szPath, pathSep)) = 0;   // Cut off the plugin's file name
    *(std::strrchr(szPath, pathSep) + 1) = 0; // Cut off the "64" directory name, but leave the dir separation character
    // We search in a subdirectory named "Resources" for all we need
    std::string resourcePath = szPath;
    resourcePath += "Resources";            // should now be something like ".../Resources/plugins/XPMP2-Sample/Resources"

    // Try initializing XPMP2:
    const char* res = XPMPMultiplayerInit(REMOTE_CLIENT_NAME,      // plugin name,
        resourcePath.c_str(),    // path to supplemental files
        CBIntPrefsFunc,          // configuration callback function
        "A320",                  // default ICAO type
        REMOTE_CLIENT_LOG2);     // plugin short name
    if (res[0]) {
        LOG_MSG(logFATAL, "Initialization of XPMP2 failed: %s", res);
        return 0;
    }

    // Load our CSL models
    res = XPMPLoadCSLPackage(resourcePath.c_str());     // CSL folder root path
    if (res[0]) {
        LOG_MSG(logERR, "Error while loading CSL packages: %s", res);
    }

    // Create the menu for the plugin
    int my_slot = XPLMAppendMenuItem(XPLMFindPluginsMenu(), REMOTE_CLIENT_NAME, NULL, 0);
    hMenu = XPLMCreateMenu(REMOTE_CLIENT_NAME, XPLMFindPluginsMenu(), my_slot, NULL, NULL);

    // No CSL models installed?
    if (XPMPGetNumberOfInstalledModels() <= 0) {
        XPLMAppendMenuItem(hMenu, "Disabled - No CSL models installed!", (void*)MENU_ACTIVE, 0);
        XPLMEnableMenuItem(hMenu, 0, false);
        LOG_MSG(logFATAL, "There are no CSL models installed, XPMP2 Remote Client CANNOT START!");
        LOG_MSG(logFATAL, "Make sure the same set of CSL models is available under XPMP2-Remote/Resources as is for your sending plugins.");
        return 1;
    }

    // Define "proper" command and menu items
    for (CmdMenuDefTy& cmdDef: CMD_MENU_DEF) {
        cmdDef.hCmd = XPLMCreateCommand(cmdDef.cmdName, cmdDef.description);
        XPLMRegisterCommandHandler(cmdDef.hCmd, CmdCallback, 1, NULL);
        XPLMAppendMenuItemWithCommand(hMenu, cmdDef.menuName, cmdDef.hCmd);
    }

    // The Labels submenu has 3 options
    XPLMAppendMenuItem(hMenu, "Labels", (void*)MENU_LABELS, 0);
    hLabels = XPLMCreateMenu("Labels", hMenu, MENU_LABELS, MenuLabelsCB, NULL);
    XPLMAppendMenuItem(hLabels, "Synchronize", (void*)XPMP2RCGlobals::LABELS_SYNCH, 0);
    XPLMAppendMenuItem(hLabels, "On", (void*)XPMP2RCGlobals::LABELS_ON, 0);
    XPLMAppendMenuItem(hLabels, "Off", (void*)XPMP2RCGlobals::LABELS_OFF, 0);

    // The Senders submenu lists connected plugins with IP address and number of aircraft
    XPLMAppendMenuItem(hMenu, "Senders", (void*)MENU_SENDER, 0);
    hSenders = XPLMCreateMenu("Senders", hMenu, MENU_SENDER, NULL, NULL);
    XPLMAppendMenuItem(hSenders, "(none)", (void*)MENU_SENDER, 0);

    MenuUpdateCheckmarks();

    return 1;
}

PLUGIN_API void	XPluginStop(void)
{
    // Properly clean up
    XPMPMultiplayerCleanup();

}

PLUGIN_API int XPluginEnable(void)
{
    // Initialize the Client module
    ClientInit();

    // No CSL models installed? Then don't try starting
    if (XPMPGetNumberOfInstalledModels() <= 0) {
        return 1;
    }

    // Create a flight loop callback for some regular tasks, called every second
    XPLMCreateFlightLoop_t flParams = {
        sizeof(flParams),                           // structSize
        xplm_FlightLoop_Phase_BeforeFlightModel,    // phase
        FlightLoopCallback,                         // callbackFunc,
        nullptr                                     // refcon
    };
    flId = XPLMCreateFlightLoop(&flParams);
    XPLMScheduleFlightLoop(flId, 1.0f, true);
    
    // Activate the listener
    ClientToggleActive();
    MenuUpdateCheckmarks();
    
    // Success
    LOG_MSG(logINFO, "Enabled");
	return 1;
}

PLUGIN_API void XPluginDisable(void)
{
    // Stop our flight loop callback
    if (flId)
        XPLMDestroyFlightLoop(flId);
    flId = nullptr;

    // Cleanup the client, also removes all planes
    ClientCleanup();

    LOG_MSG(logINFO, "Disabled");
}

PLUGIN_API void XPluginReceiveMessage(XPLMPluginID who, long inMsg, void*)
{
    // Some other plugin wants TCAS/AI control, but we never release automatically
    if (inMsg == XPLM_MSG_RELEASE_PLANES) {
        LOG_MSG(logINFO, "%s requested TCAS access, but we don't release automatically", GetPluginName(who).c_str())
    }
}
